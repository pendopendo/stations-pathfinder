func dynamicDFS(trainName, startStation, endStation string, network *Network, occupiedStations, usedSegments map[string]bool, trains []*Train, visitedHistory map[string]bool) []string {
	// Initialize the stack with the start station
	stack := [][]string{{startStation}}
	// Slice to store all possible paths
	var allPaths [][]string
	// Initialize variables for the active path
	var activePath []string

	fmt.Printf("\nTrain %s: Starting DFS from %s to %s\n", trainName, startStation, endStation)

	// DFS loop
	for len(stack) > 0 {
		// Pop the last path from the stack
		currentPath := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		// Get the current station from the path
		currentStation := currentPath[len(currentPath)-1]

		// If the current station is the end station, add the path to allPaths
		if currentStation == endStation {
			allPaths = append(allPaths, currentPath)
			continue
		}

		// Iterate over all neighbors of the current station
		for _, neighbor := range network.Connections[currentStation] {
			// Avoid loops and backtracking
			if contains(currentPath, neighbor) || visitedHistory[neighbor] {
				continue
			}
			// Create a new path by copying the current path and adding the neighbor
			newPath := append([]string{}, currentPath...)
			newPath = append(newPath, neighbor)
			// Push the new path onto the stack
			stack = append(stack, newPath)
		}
	}
	fmt.Printf("Train %s: All paths found: %v\n", trainName, allPaths)

	// If no paths were found, return nil
	if len(allPaths) == 0 {
		fmt.Printf("Train %s: No path found.\n", trainName)
		return nil
	}

	// Ensure there's always a valid path to choose
	shortestPath := allPaths[0] // Default to the first found path
	var alternativePath []string

	if len(allPaths) > 1 {
		// If there's more than one path, find the shortest and an alternative
		shortestPath = allPaths[0]
		alternativePath = allPaths[1]

		for _, path := range allPaths {
			if len(path) < len(shortestPath) {
				alternativePath = shortestPath // Keep track of previous shortest as alternative
				shortestPath = path
			} else if len(alternativePath) == 0 || (len(path) < len(alternativePath) && !reflect.DeepEqual(path, shortestPath)) {
				alternativePath = path
			}
		}
	}

	// Get the train's index in the train list for threshold calculation
	numTrains := len(trains)
	currentTrain := 0
	for i, train := range trains {
		if train.Name == trainName {
			currentTrain = i + 1
			break
		}
	}

	// Check availability of the shortest path
	available := true
	if len(shortestPath) > 1 {
		segment := fmt.Sprintf("%s-%s", shortestPath[0], shortestPath[1])
		if occupiedStations[shortestPath[1]] || usedSegments[segment] {
			available = false
		}
	}

	// Decide on the path: If the shortest path is blocked, consider the alternative
	if !available && alternativePath != nil && len(alternativePath) > 1 {
		threshold := numTrains - currentTrain + len(shortestPath)
		if threshold >= len(alternativePath) {
			// Choose the alternative path if it's better than waiting
			activePath = alternativePath
		}
	} else if available {
		// Choose the shortest path if it's available
		activePath = shortestPath
	}

	// If no available path was found, return nil
	if activePath == nil {
		fmt.Printf("Train %s: No available path found.\n", trainName)
		return nil
	}

	// Print the selected path
	fmt.Printf("Train %s: Selected path: %v\n", trainName, activePath)

	// Return the selected path
	return activePath
}
